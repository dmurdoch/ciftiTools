% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/view_xifti_surface.R
\name{view_xifti_surface}
\alias{view_xifti_surface}
\alias{view_cifti_surface}
\alias{viewCIfTI_surface}
\alias{viewcii_surface}
\title{View cortical surface}
\usage{
view_xifti_surface(
  xifti = NULL,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  view = c("both", "lateral", "medial"),
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_ncol = NULL,
  legend_embed = NULL,
  digits = NULL,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  width = NULL,
  height = NULL,
  zoom = NULL
)

view_cifti_surface(
  xifti,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  view = c("both", "lateral", "medial"),
  widget = TRUE,
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_ncol = NULL,
  legend_embed = NULL,
  digits = NULL,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  width = NULL,
  height = NULL,
  zoom = NULL
)

viewCIfTI_surface(
  xifti,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  view = c("both", "lateral", "medial"),
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_ncol = NULL,
  legend_embed = NULL,
  digits = NULL,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  width = NULL,
  height = NULL,
  zoom = NULL
)

viewcii_surface(
  xifti,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  view = c("both", "lateral", "medial"),
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_ncol = NULL,
  legend_embed = NULL,
  digits = NULL,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  width = NULL,
  height = NULL,
  zoom = NULL
)
}
\arguments{
\item{xifti}{Object of class "xifti". 
See \code{\link{is.xifti}} and \code{\link{make_xifti}}.}

\item{surfL, surfR}{(Optional) The brain surface model to use.
Each can be a file path for a GIFTI, a file read by gifti::readgii,
or a list with components "vertices" and "faces". If provided, they will override
\code{xifti$surf$cortex_left} and \code{xifti$surf$cortex_right} if those exist.
Leave as \code{NULL} (default) to use \code{xifti$surf$cortex_left} and 
\code{xifti$surf$cortex_right} if those exist, or the default inflated surfaces
if those do not exist.}

\item{color_mode}{(Optional) \code{"sequential"}, \code{"qualitative"},
\code{"diverging"}, or \code{"auto"} (default). Auto mode will use the
qualitative color mode if the \code{"xifti"} object represents a .dlabel 
CIFTI (intent 3007). Otherwise, it will use the diverging mode if the data
contains both positive and negative values, and the sequential mode if the
data contains >90% positive or >90% negative values. See 
\code{\link{make_color_pal}} for more details.}

\item{zlim}{(Optional) Controls the mapping of values to each
color in \code{colors}. If the length is longer than
one, using -Inf will set the value to the data minimum, and Inf will set
the value to the data maximum. See \code{\link{make_color_pal}} 
description for more details.}

\item{colors}{(Optional) "ROY_BIG_BL", vector of colors to use,
the name of a ColorBrewer palette (see \code{RColorBrewer::brewer.pal.info}
and colorbrewer2.org), or the name of a viridisLite palette. 
Defaults are \code{"ROY_BIG_BL"} (sequential),
\code{"Set2"} (qualitative), and \code{"ROY_BIG_BL"} (diverging). An exception
to these defaults is if the \code{"xifti"} object represents a .dlabel CIFTI (intent 3007),
then the qualitative colors in the label table will be used.
See \code{\link{make_color_pal}} for more details.}

\item{idx}{The time/column index of the data to display. 

 If its length is greater than one and \code{!save}, will display the results
 in an htmlwidget with a slider to control what time/column is being displayed.
 The OpenGL window will display all meshes on top of one another; it should be
 closed manually.}

\item{hemisphere}{Which brain cortex to display: "both" (default), "left",
 or "right". Each will be plotted in a separate panel column.

 If a brain cortex is requested but no surface is available, a default
 inflated surface will be used.

 This argument can also be \code{NULL} (default). In this case, the default
 inflated surface included with \code{ciftiTools} will be used for each
 cortex with data (i.e. if \code{xifti$data$cortex_left} and/or 
 \code{xifti$data$cortex_right} exist).

 Surfaces without data will be colored white.}

\item{view}{Which view to display: \code{"lateral"}, \code{"medial"}, or 
\code{"both"}. If \code{NULL} (default), both views will be shown. Each view 
will be plotted in a separate panel row.}

\item{title}{Optional title(s) for the plot(s). It will be printed at the top 
 in a separate subplot with 1/4 the height of the brain cortex subplots.
 
 Default: \code{NULL} will use the time index (".dtseries") or name
 (.dscalar or .dlabel) of the data column being plotted. 

 To use a custom title(s), use a length 1 character vector (same title for
 each plot) or length \code{length(idx)} character vector (different title
 for each plot). Set to an empty string \code{""} to omit the title. 

 If the title is non-empty but does not appear, \code{cex.title} may need to 
 be lowered.}

\item{slider_title}{Text at bottom of plot that will be added if a widget
is used, to provide a title for the slider. Default: \code{"Index"}.
If \code{NULL}, no title will be added.}

\item{fname}{Save the plot(s), and color legend(s) if applicable, to png files?
 Set \code{fname} to \code{FALSE} (default) to not save any files. Otherwise, each
 index (and corresponding legend, if applicable) will be saved to a file.
 Set \code{fname} to \code{TRUE} to name the files by the data column names. (Spaces
 will be replaced with underscores). Set \code{fname} to a length 1 character vector
 to name files by this suffix followed by the \code{suffix}: either the
 data column names (\code{"names"}) or the index value (\code{"idx"}). 
 Set this to a character vector with the same length as \code{idx} to name 
 the files exactly. 

 The color legend(s) will be saved to "[surf_fname_for_this_idx]_legend.png".}

\item{fname_suffix}{Save the plot(s), and color legend(s) if applicable, to png files?
 Set \code{fname} to \code{FALSE} (default) to not save any files. Otherwise, each
 index (and corresponding legend, if applicable) will be saved to a file.
 Set \code{fname} to \code{TRUE} to name the files by the data column names. (Spaces
 will be replaced with underscores). Set \code{fname} to a length 1 character vector
 to name files by this suffix followed by the \code{suffix}: either the
 data column names (\code{"names"}) or the index value (\code{"idx"}). 
 Set this to a character vector with the same length as \code{idx} to name 
 the files exactly. 

 The color legend(s) will be saved to "[surf_fname_for_this_idx]_legend.png".}

\item{legend_ncol}{Number of columns in color legend. If
\code{NULL} (default), use 10 entries per row. Only applies if the color
legend is used (qualitative data).}

\item{legend_embed}{Should the colorbar be embedded in the plot?
It will be positioned in the bottom-left corner, in a separate subplot
with 1/4 the height of the brain cortex subplots. Default: \code{TRUE}.
If \code{FALSE}, print it separately instead. Only applies if the color
bar is used (sequential or diverging data).}

\item{digits}{The number of digits for the colorbar legend ticks.
If \code{NULL} (default), let \code{\link{format}} decide.}

\item{cex.title}{Font size multiplier for the title. \code{NULL} (default)
will use \code{2} for titles less than 20 characters long, and smaller
sizes for increasingly longer titles.}

\item{text_color}{Color for text in title and colorbar legend. Default:
"black".}

\item{bg}{Background color. \code{NULL} will not color the background (white).}

\item{borders}{Only applicable if \code{color_mode} is \code{"qualitative"}.
Border vertices will be identified (those that share a face with at least 
one vertex of a different value) and colored over. If this argument is
\code{TRUE} borders will be colored in black; provide the name of a different
color to use that instead. If \code{FALSE} or \code{NULL} (default), do
not draw borders.}

\item{alpha}{Transparency value for mesh coloring, between 0 and 1. Default:
\code{1.0} (no transparency).}

\item{edge_color}{Outline each edge in this color. Default: \code{NULL} (do
not outline the edges).}

\item{vertex_color}{Draw each vertex in this color. Default: 
\code{"black"}. Vertices are only drawn if \code{vertex_size > 0}}

\item{vertex_size}{Draw each vertex with this size. Default: \code{0} 
(do not draw the vertices).}

\item{width}{The dimensions of the RGL window, in pixels. If both are
\code{NULL} (default), the dimensions will be set to
1000 (width) x 700 (height) for 1x1 and 2x2 subplots,
1500 x 525 for 2x1 subplots, and
500 x 700 for 1x2 subplots. These defaults are chosen to fit comfortably
within a 1600 x 900 screen. Specifying only one will set the other to maintain
the same aspect ratio. Both can be specified to set the dimensions exactly.}

\item{height}{The dimensions of the RGL window, in pixels. If both are
\code{NULL} (default), the dimensions will be set to
1000 (width) x 700 (height) for 1x1 and 2x2 subplots,
1500 x 525 for 2x1 subplots, and
500 x 700 for 1x2 subplots. These defaults are chosen to fit comfortably
within a 1600 x 900 screen. Specifying only one will set the other to maintain
the same aspect ratio. Both can be specified to set the dimensions exactly.}

\item{zoom}{Adjustment to size of brain meshes. Default: \code{3/5}
(100\% + 3/5*100\% = 160\% the original size).}
}
\value{
If \code{save} and \code{close_after_save}, the name(s) of the image
 file(s) that were written. 

 Otherwise, if the length of \code{idx} is equal to one, a list of the rgl
 object IDs which can be used to further manipulate the Open GL window; if
 the length of \code{idx} is greater than one, the htmlwidget with slider
 to interactively control which timepoint is being displayed.
}
\description{
Visualize \code{"xifti"} cortical data using an interactive Open GL window
 made with \code{rgl}. Can also render an htmlwidget to control display of
 multiple timepoints. The \code{rmarkdown} package is required for the htmlwidget
 functionality.
}
\section{Navigating and Embedding the Interactive Plots}{

 This function opens an interactive Open GL window rendered by \code{rgl}. 
 If \code{save==TRUE} and \code{close_after_save==TRUE}, the window will be
 closed after the function call. Otherwise, it is kept open and the following
 information applies:

 To navigate the plot, left click and drag the cursor to rotate. Use the 
 scroll wheel or right click and drag to zoom. Press the scroll wheel and drag
 to change the field-of-view. Execute \code{\link[rgl]{snapshot}} to save the
 current window as a .png file. Execute \code{\link[rgl:rgl.open]{rgl.close}} to close
 the window. \code{\link[rgl:viewpoint]{rgl.viewpoint}} can be used for programmatic
 navigation. 

 The Open GL window can be embedded as an htmlwidget in an R Markdown document
 using one of two methods. The first is executing \code{\link[rgl]{rglwidget}}
 in the chunk where the plot is made. This first method should work within
 both the RStudio IDE and a knitted .html file. The second method is 
 executing \code{rgl::hook_rgl} at the start of the document and 
 then using the chunk option \code{webgl=TRUE} in the chunk where the plot is
 made. The second method is specifically for knitted .html files. Although
 the first method is the newest approach and is recommended by others, we
 used the second method in the \code{ciftiTools} vignette because the first
 is not compatible with htmlpreview. For both methods, the window still
 needs to be open to render the widget. Also for both methods, you will 
 probably need to tweak the image dimensions e.g. 
 \code{fig.width=8, fig.height=5} in the chunk options, because it uses the 
 defaults from RMarkdown/Knitr instead of what makes sense based on the 
 dimensions of the Open GL window.
 
 For \code{view_xifti_surface}, if \code{length(idx) > 1}, this function will
 automatically return an htmlwidget using the first method, but with a
 \code{\link[rgl]{playwidget}} wrapper to add a slider to control which
 column index is being displayed. All the meshes will be rendered on top of
 one another in the Open GL window, so only the widget will be useful for
 viewing the data interactively. Since it uses the first method, it will not
 be visible with htmlpreview. No additional call to 
 \code{\link[rgl]{rglwidget}} is necessary, but \code{\link[rgl:rgl.open]{rgl.close}}
 must be called in a following chunk to close the Open GL window.
}

\section{Embedding the Static Plots}{

 If \code{save==TRUE}, the plot(s) is written to a .png file. (For 
 \code{view_xifti_surface}, if \code{length(idx) > 1}, each \code{idx} will
 be written to a separate image file.) You can use 
 \code{\link[knitr]{include_graphics}} to embed an image file in an R
 Markdown document. If \code{close_after_save==TRUE}, the return value of this
 function call is the name(s) of the image file(s) that were written, so it
 can be used directly to display the image.

 There's an additional way to embed an image of this plot without writing a
 .png file: use \code{save==FALSE} and set the chunk options 
 \code{rgl=TRUE, format="png"}. You will probably need to tweak the image
 dimensions e.g. \code{fig.width=8, fig.height=5} in the chunk options, 
 because it uses the defaults from RMarkdown/Knitr instead of what makes
 sense based on the dimensions of the Open GL window.
}

